"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerProcessExit = exports.address = exports.findSWAConfigFile = exports.traverseFolder = exports.parsePort = exports.computeAppLocationFromArtifactLocation = exports.parseUrl = exports.validateDevServerConfig = exports.isHttpUrl = exports.isAcceptingTcpConnections = exports.argv = exports.readWorkflowFile = exports.validateUserConfig = exports.decodeCookie = exports.serializeCookie = exports.validateCookie = exports.response = exports.logger = void 0;
const chalk_1 = __importDefault(require("chalk"));
const cookie_1 = __importDefault(require("cookie"));
const fs_1 = __importStar(require("fs"));
const net_1 = __importDefault(require("net"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
const config_1 = require("../config");
const runtimes_1 = require("./runtimes");
const { readdir, readFile } = fs_1.promises;
exports.logger = {
    _print(prefix, data) {
        if (prefix) {
            console.log(chalk_1.default.dim.gray(`[${prefix}]`), data);
        }
        else {
            console.log(data);
        }
    },
    _traverseObjectProperties(o, fn, indent = "") {
        for (const i in o) {
            if (Array.isArray(o) || (typeof o === "object" && o.hasOwnProperty(i))) {
                if (o[i] !== null && typeof o[i] === "object") {
                    fn(i, null, `${indent}`);
                    this._traverseObjectProperties(o[i], fn, ` ${indent}`);
                }
                else {
                    fn(i, o[i], ` ${indent}`);
                }
            }
        }
    },
    // public methods
    info(data, prefix = "swa") {
        this.silly(data, prefix, "info");
    },
    log(data) {
        this.silly(data, null, "log");
    },
    error(data, exit = false) {
        const { SWA_CLI_DEBUG } = process.env;
        if (!SWA_CLI_DEBUG || (SWA_CLI_DEBUG === null || SWA_CLI_DEBUG === void 0 ? void 0 : SWA_CLI_DEBUG.includes("silent"))) {
            return;
        }
        console.error(chalk_1.default.red(data));
        if (exit) {
            process.exit(-1);
        }
    },
    silly(data, prefix = null, debugFilter = "silly") {
        const { SWA_CLI_DEBUG } = process.env;
        if (!SWA_CLI_DEBUG || (SWA_CLI_DEBUG === null || SWA_CLI_DEBUG === void 0 ? void 0 : SWA_CLI_DEBUG.includes("silent"))) {
            return;
        }
        this._print(prefix, ``);
        if ((SWA_CLI_DEBUG === null || SWA_CLI_DEBUG === void 0 ? void 0 : SWA_CLI_DEBUG.includes("silly")) || (SWA_CLI_DEBUG === null || SWA_CLI_DEBUG === void 0 ? void 0 : SWA_CLI_DEBUG.includes(debugFilter))) {
            if (typeof data === "object") {
                this._traverseObjectProperties(data, (key, value, indent) => {
                    if (value !== null) {
                        value = typeof value === "undefined" ? chalk_1.default.gray("<undefined>") : value;
                        this._print(prefix, `${indent}- ${key}: ${chalk_1.default.green(value)}`);
                    }
                    else {
                        this._print(prefix, `${indent}- ${key}:`);
                    }
                });
            }
            else {
                // data is not an object so just print its value even if it's null or undefined
                this._print(prefix, data);
            }
        }
    },
};
const response = ({ status, headers, cookies, body = "" }) => {
    if (typeof status !== "number") {
        throw Error("TypeError: status code must be a number.");
    }
    body = body || null;
    const res = {
        status,
        cookies,
        headers: {
            status,
            "Content-Type": "application/json",
            ...headers,
        },
        body,
    };
    return res;
};
exports.response = response;
const validateCookie = (cookieValue) => {
    if (typeof cookieValue !== "string") {
        throw Error(`TypeError: cookie value must be a string.`);
    }
    const cookies = cookie_1.default.parse(cookieValue);
    return !!cookies.StaticWebAppsAuthCookie;
};
exports.validateCookie = validateCookie;
const serializeCookie = (cookieName, cookieValue, options) => {
    return cookie_1.default.serialize(cookieName, cookieValue, options);
};
exports.serializeCookie = serializeCookie;
const decodeCookie = (cookieValue) => {
    const cookies = cookie_1.default.parse(cookieValue);
    if (cookies.StaticWebAppsAuthCookie) {
        const decodedValue = Buffer.from(cookies.StaticWebAppsAuthCookie, "base64").toString();
        return JSON.parse(decodedValue);
    }
    return null;
};
exports.decodeCookie = decodeCookie;
function validateUserConfig(userConfig) {
    let appLocation = undefined;
    let apiLocation = undefined;
    let appArtifactLocation = undefined;
    if (userConfig === null || userConfig === void 0 ? void 0 : userConfig.appLocation) {
        appLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.appLocation || `.${path_1.default.sep}`));
        if (path_1.default.isAbsolute(userConfig.appLocation)) {
            appLocation = userConfig.appLocation;
        }
    }
    if (userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation) {
        if (isHttpUrl(userConfig.apiLocation)) {
            apiLocation = userConfig.apiLocation;
        }
        else {
            // use the user's config and construct an absolute path
            apiLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.apiLocation));
        }
        if (path_1.default.isAbsolute(userConfig.apiLocation)) {
            apiLocation = userConfig.apiLocation;
        }
    }
    if (userConfig === null || userConfig === void 0 ? void 0 : userConfig.appArtifactLocation) {
        // is dev server url
        if (isHttpUrl(userConfig.appArtifactLocation)) {
            appArtifactLocation = userConfig.appArtifactLocation;
        }
        else {
            appArtifactLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.appArtifactLocation || `.${path_1.default.sep}`));
            if (path_1.default.isAbsolute(userConfig.appArtifactLocation)) {
                appArtifactLocation = userConfig.appArtifactLocation;
            }
        }
    }
    return {
        appLocation,
        apiLocation,
        appArtifactLocation,
    };
}
exports.validateUserConfig = validateUserConfig;
const readWorkflowFile = ({ userConfig } = {}) => {
    let isAppDevServer = false;
    let isApiDevServer = false;
    if (userConfig) {
        // is dev servers? Skip reading workflow file
        isAppDevServer = isHttpUrl(userConfig === null || userConfig === void 0 ? void 0 : userConfig.appArtifactLocation);
        isApiDevServer = isHttpUrl(userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation);
        if (isAppDevServer && isApiDevServer) {
            return userConfig && validateUserConfig(userConfig);
        }
    }
    const infoMessage = `GitHub Actions configuration was not found under ".github/workflows/"`;
    const githubActionFolder = path_1.default.resolve(process.cwd(), ".github/workflows/");
    // does the config folder exist?
    if (fs_1.default.existsSync(githubActionFolder) === false) {
        exports.logger.info(infoMessage);
        return userConfig && validateUserConfig(userConfig);
    }
    // find the SWA GitHub action file
    // TODO: handle multiple workflow files (see #32)
    let githubActionFile = fs_1.default
        .readdirSync(githubActionFolder)
        .filter((file) => file.includes("azure-static-web-apps") && file.endsWith(".yml"))
        .pop();
    // does the config file exist?
    if (!githubActionFile || fs_1.default.existsSync(githubActionFile)) {
        exports.logger.info(infoMessage);
        return userConfig && validateUserConfig(userConfig);
    }
    githubActionFile = path_1.default.resolve(githubActionFolder, githubActionFile);
    let githubActionContent = fs_1.default.readFileSync(githubActionFile, "utf8");
    if (typeof githubActionContent !== "string") {
        throw Error("TypeError: GitHub action file content should be a string");
    }
    // MOTE: the YAML library will parse and return properties as sanke_case
    // we will convert those properties to camelCase at the end of the function
    const swaYaml = yaml_1.default.parse(githubActionContent);
    if (!swaYaml) {
        throw Error(`could not parse the SWA workflow file "${githubActionFile}". Make sure it's a valid YAML file.`);
    }
    if (!swaYaml.jobs) {
        throw Error(`missing property 'jobs' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaYaml.jobs.build_and_deploy_job) {
        throw Error(`missing property 'jobs.build_and_deploy_job' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaYaml.jobs.build_and_deploy_job.steps) {
        throw Error(`missing property 'jobs.build_and_deploy_job.steps' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    // hacking this to have an `any` on the type in .find, mainly because a typescript definition for the YAML file is painful...
    const swaBuildConfig = swaYaml.jobs.build_and_deploy_job.steps.find((step) => step.uses && step.uses.includes("static-web-apps-deploy"));
    if (!swaBuildConfig) {
        throw Error(`invalid property 'jobs.build_and_deploy_job.steps[]' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaBuildConfig.with) {
        throw Error(`missing property 'jobs.build_and_deploy_job.steps[].with' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    // extract the user's config and set defaults
    let { app_build_command = config_1.DEFAULT_CONFIG.appBuildCommand, api_build_command = config_1.DEFAULT_CONFIG.apiBuildCommand, app_location = config_1.DEFAULT_CONFIG.appLocation, app_artifact_location = config_1.DEFAULT_CONFIG.appArtifactLocation, api_location = config_1.DEFAULT_CONFIG.apiLocation, } = swaBuildConfig.with;
    // the following locations (extracted from the config) should be under the user's project folder:
    // - app_location
    // - api_location
    // - app_artifact_location
    app_location = path_1.default.normalize(path_1.default.join(process.cwd(), app_location));
    if (typeof api_location !== "undefined") {
        api_location = path_1.default.normalize(path_1.default.join(process.cwd(), api_location || path_1.default.sep));
    }
    app_artifact_location = path_1.default.normalize(app_artifact_location);
    const detectedRuntimeType = runtimes_1.detectRuntime(app_location);
    if (detectedRuntimeType === runtimes_1.RuntimeType.dotnet) {
        // TODO: work out what runtime is being used for .NET rather than hard-coded
        app_artifact_location = path_1.default.join(app_location, "bin", "Debug", "netstandard2.1", "publish", app_artifact_location);
    }
    else {
        app_artifact_location = path_1.default.join(app_location, app_artifact_location);
    }
    // override SWA config with user's config (if provided):
    // if the user provides different app location, app artifact location or api location, use that information
    if (userConfig) {
        userConfig = validateUserConfig(userConfig);
        app_location = userConfig === null || userConfig === void 0 ? void 0 : userConfig.appLocation;
        app_artifact_location = userConfig === null || userConfig === void 0 ? void 0 : userConfig.appArtifactLocation;
        api_location = userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation;
    }
    const files = isAppDevServer && isApiDevServer ? undefined : [githubActionFile];
    // convert variable names to camelCase
    // instead of snake_case
    const config = {
        appBuildCommand: isAppDevServer ? undefined : app_build_command,
        apiBuildCommand: isApiDevServer ? undefined : api_build_command,
        appLocation: app_location,
        apiLocation: api_location,
        appArtifactLocation: app_artifact_location,
        files,
    };
    exports.logger.silly({ config }, "utils");
    return config;
};
exports.readWorkflowFile = readWorkflowFile;
/**
 * Parse process.argv and retrieve a specific flag value.
 * Usage:
 * ```
 * // ./server --port 4242
 * let port = argv<number>('--port');
 * ```
 *
 * @param flag the flag name to retrieve from argv, e.g.: --port
 * @returns {T} the value of the corresponding flag:
 * - if flag is --key=value or --key value, returns value as type `T`.
 * - if flag is --key, return a boolean (true if the flag is present, false if not).
 * - if flag is not present, return null.
 *
 */
function argv(flag) {
    var _a;
    const flags = process.argv;
    for (let index = 0; index < flags.length; index++) {
        const entry = flags[index];
        // ex: --key=value
        if (entry.startsWith("--")) {
            if (entry.includes("=")) {
                // ex: [--key, value]
                const [key, value] = entry.split("=");
                if (flag === key.trim()) {
                    // ex: --key=value --> value
                    // ex: --key=      --> null
                    return (!!value ? value.trim() : null);
                }
            }
            // ex: --key value
            // ex: --key
            else if (flag === entry.trim()) {
                const nextEntry = (_a = flags[index + 1]) === null || _a === void 0 ? void 0 : _a.trim();
                // ex: --key
                if (nextEntry === undefined || (nextEntry === null || nextEntry === void 0 ? void 0 : nextEntry.startsWith("--"))) {
                    return true;
                }
                // ex: --key value
                else if (!!nextEntry) {
                    return nextEntry;
                }
            }
            else {
                // flag wasn't found
                return false;
            }
        }
    }
    return null;
}
exports.argv = argv;
function isAcceptingTcpConnections({ host = "127.0.0.1", port }) {
    return new Promise((resolve) => {
        const socket = net_1.default.createConnection(port, host);
        socket
            .once("error", () => {
            resolve(false);
            socket.end();
        })
            .once("connect", () => {
            resolve(true);
            socket.end();
        });
    });
}
exports.isAcceptingTcpConnections = isAcceptingTcpConnections;
function isHttpUrl(input) {
    try {
        const url = new URL(input);
        return url.protocol.startsWith("http");
    }
    catch {
        return false;
    }
}
exports.isHttpUrl = isHttpUrl;
async function validateDevServerConfig(context) {
    let { hostname, port } = parseUrl(context);
    try {
        const appListening = await isAcceptingTcpConnections({ port, host: hostname });
        if (appListening === false) {
            exports.logger.error(`Could not connect to "${context}". Is the server up and running?`);
            process.exit(-1);
        }
        else {
            return context;
        }
    }
    catch (err) {
        if (err.message.includes("EACCES")) {
            exports.logger.error(`Port "${port}" cannot be used. You might need elevated or admin privileges. Or, use a valid port: 1024 to 49151.`);
        }
        else {
            exports.logger.error(err.message);
        }
        process.exit(-1);
    }
}
exports.validateDevServerConfig = validateDevServerConfig;
function parseUrl(url) {
    const { protocol, port, host, hostname } = new URL(url);
    return {
        protocol,
        port: Number(port),
        host,
        hostname,
    };
}
exports.parseUrl = parseUrl;
// @TODO
function computeAppLocationFromArtifactLocation(appArtifactLocation) {
    if (appArtifactLocation) {
        return path_1.default.dirname(appArtifactLocation).split(path_1.default.sep).pop();
    }
    return undefined;
}
exports.computeAppLocationFromArtifactLocation = computeAppLocationFromArtifactLocation;
function parsePort(port) {
    const portNumber = parseInt(port, 10);
    if (isNaN(portNumber)) {
        exports.logger.error(`Port "${port}" is not a number.`, true);
    }
    else {
        if (portNumber < 1024 || portNumber > 49151) {
            exports.logger.error(`Port "${port}" is out of range. Allowed ports are from 1024 to 49151.`, true);
        }
    }
    return portNumber;
}
exports.parsePort = parsePort;
async function* traverseFolder(folder) {
    const folders = (await readdir(folder, { withFileTypes: true }));
    for (const folderEntry of folders) {
        if (folderEntry.name.includes("node_modules")) {
            // ignore folder
            continue;
        }
        const entryPath = path_1.default.resolve(folder, folderEntry.name);
        if (folderEntry.isDirectory()) {
            yield* traverseFolder(entryPath);
        }
        else {
            yield entryPath;
        }
    }
}
exports.traverseFolder = traverseFolder;
async function findSWAConfigFile(folder) {
    const configFiles = new Map();
    for await (const file of traverseFolder(folder)) {
        const filename = path_1.default.basename(file);
        if (filename === config_1.DEFAULT_CONFIG.swaConfigFilename || filename === config_1.DEFAULT_CONFIG.swaConfigFilenameLegacy) {
            const config = JSON.parse((await readFile(file)).toString("utf-8"));
            // make sure we are using the right SWA config file.
            // Note: some JS frameworks (eg. Nuxt, Scully) use routes.json as part of their config. We need to ignore those
            const isValidSWAConfigFile = config.globalHeaders || config.mimeTypes || config.navigationFallback || config.responseOverrides || config.routes;
            if (isValidSWAConfigFile) {
                const isLegacyConfigFile = filename === config_1.DEFAULT_CONFIG.swaConfigFilenameLegacy;
                configFiles.set(filename, { file, isLegacyConfigFile });
            }
        }
    }
    // take staticwebapp.config.json if it exists (and ignore routes.json legacy file)
    if (configFiles.has(config_1.DEFAULT_CONFIG.swaConfigFilename)) {
        return configFiles.get(config_1.DEFAULT_CONFIG.swaConfigFilename);
    }
    // legacy config file
    else if (configFiles.has(config_1.DEFAULT_CONFIG.swaConfigFilenameLegacy)) {
        return configFiles.get(config_1.DEFAULT_CONFIG.swaConfigFilenameLegacy);
    }
    // no config file found
    return null;
}
exports.findSWAConfigFile = findSWAConfigFile;
const address = (host, port) => {
    const protocol = `http`;
    if (!host) {
        throw new Error(`Host value is not set`);
    }
    let uri = port ? `${protocol}://${host}:${port}` : `${protocol}://${host}`;
    try {
        new URL(uri);
    }
    catch (error) {
        throw new Error(`Address: ${uri} is malformed!`);
    }
    return uri;
};
exports.address = address;
const registerProcessExit = (fn) => {
    let terminated = false;
    const wrapper = () => {
        if (!terminated) {
            terminated = true;
            fn();
        }
    };
    process.on("SIGINT", wrapper);
    process.on("SIGTERM", wrapper);
    process.on("exit", wrapper);
};
exports.registerProcessExit = registerProcessExit;
//# sourceMappingURL=utils.js.map
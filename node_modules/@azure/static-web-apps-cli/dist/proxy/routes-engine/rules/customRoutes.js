"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customRoutes = exports.matchRoute = void 0;
const globalyzer_1 = __importDefault(require("globalyzer"));
const globrex_1 = __importDefault(require("globrex"));
const utils_1 = require("../../../core/utils");
const matchRoute = (req, isLegacyConfigFile) => {
    var _a;
    const sanitizedUrl = new URL(req.url, `http://${(_a = req === null || req === void 0 ? void 0 : req.headers) === null || _a === void 0 ? void 0 : _a.host}`);
    return (routeDef) => {
        let filter = routeDef.route;
        if (!filter) {
            return false;
        }
        const originlUrl = sanitizedUrl.pathname;
        // In the legacy config file,
        // the /* rule should only match routes segments (eg. /about), but not file paths (eg. image.png)
        // bypass rules for /api and /.auth routes
        if (isLegacyConfigFile && filter === "/*") {
            if (originlUrl.startsWith("/api") || originlUrl.startsWith("/.auth")) {
                return false;
            }
            else if (originlUrl.includes(".") && !originlUrl.startsWith("/.auth")) {
                return false;
            }
            else if (originlUrl.includes("sockjs")) {
                return false;
            }
        }
        // we don't support full globs in the config file.
        // add this little workaround to convert a wildcard into a valid glob pattern
        filter = filter.replace("/*", "/**/*");
        // extract glob metadata
        const globSegments = globalyzer_1.default(filter);
        // if filter and url segments don't have a commom base path
        // don't process regex, just return false
        if (originlUrl.startsWith(globSegments.base)) {
            const { regex } = globrex_1.default(globSegments.glob, { globstar: true, extended: true });
            // extract the last segment (what comes after the base) from the URL:
            // /                    => <empty string>
            // /bar.gif             => bar.gif
            // /images/foo/bar.gif  => bar.gif
            let lastSegmentFromUrl = originlUrl.replace(`${globSegments.base}`, "");
            // globrex generates regex that doesn't match leading forwardslash, so we remove it
            // before processing the regex
            lastSegmentFromUrl = lastSegmentFromUrl.replace(/^\//, "");
            return regex.test(lastSegmentFromUrl);
        }
        else {
            return false;
        }
    };
};
exports.matchRoute = matchRoute;
const customRoutes = async (req, res, userDefinedRoute) => {
    var _a;
    if (!req) {
        return Promise.resolve(undefined);
    }
    if (userDefinedRoute) {
        // set headers
        if (userDefinedRoute.headers) {
            for (const header in userDefinedRoute.headers) {
                res.setHeader(header, userDefinedRoute.headers[header]);
            }
        }
        // check allowed method
        if (((_a = userDefinedRoute.methods) === null || _a === void 0 ? void 0 : _a.includes(req.method)) === false) {
            res.statusCode = 405;
        }
        // ACL
        if (userDefinedRoute.allowedRoles) {
            const user = req.headers.cookie ? utils_1.decodeCookie(req.headers.cookie) : null;
            if (userDefinedRoute.allowedRoles.some((role) => { var _a; return (_a = user === null || user === void 0 ? void 0 : user.userRoles) === null || _a === void 0 ? void 0 : _a.some((userRole) => userRole === role); }) === false) {
                res.statusCode = 403;
            }
            else {
                res.statusCode = 200;
            }
        }
        // specific status code but no attached route
        if (userDefinedRoute.statusCode && !userDefinedRoute.serve) {
            const code = Number(userDefinedRoute.statusCode);
            if (isNaN(code) === false) {
                res.statusCode = code;
            }
        }
        // rewrite
        const isServeWrite = userDefinedRoute.serve && ![301, 302].includes(Number(userDefinedRoute.statusCode));
        if (isServeWrite || userDefinedRoute.rewrite) {
            req.url = userDefinedRoute.serve || userDefinedRoute.rewrite;
        }
        // redirect route
        const isServeRedirect = userDefinedRoute.serve && [301, 302].includes(Number(userDefinedRoute.statusCode));
        if (isServeRedirect || userDefinedRoute.redirect) {
            let route = (userDefinedRoute.serve || userDefinedRoute.redirect);
            // redirects
            // note: adding checks to avoid ERR_TOO_MANY_REDIRECTS
            if (route !== req.url) {
                res.writeHead(Number(userDefinedRoute.statusCode) || 302, {
                    Location: route,
                });
                res.end();
            }
        }
    }
    return Promise.resolve(undefined);
};
exports.customRoutes = customRoutes;
//# sourceMappingURL=customRoutes.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const concurrently_1 = __importDefault(require("concurrently"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const builder_1 = __importDefault(require("../../core/builder"));
const utils_1 = require("../../core/utils");
async function start(startContext, options) {
    var _a, _b, _c, _d;
    let useAppDevServer = undefined;
    let useApiDevServer = undefined;
    if (utils_1.isHttpUrl(startContext)) {
        useAppDevServer = await utils_1.validateDevServerConfig(startContext);
        options.appArtifactLocation = useAppDevServer;
    }
    else {
        // start the emulator from a specific artifact folder, if folder exists
        if (await utils_1.isAcceptingTcpConnections({ host: options.host, port: options.port })) {
            utils_1.logger.error(`Port ${options.port} is already used. Choose a different port.`, true);
        }
        if (fs_1.default.existsSync(startContext)) {
            options.appArtifactLocation = startContext;
        }
        else {
            // prettier-ignore
            utils_1.logger.error(`The dist folder "${startContext}" is not found.\n` +
                `Make sure that this folder exists or use the --build option to pre-build the static app.`, true);
        }
    }
    if (options.apiLocation) {
        if (utils_1.isHttpUrl(options.apiLocation)) {
            useApiDevServer = await utils_1.validateDevServerConfig(options.apiLocation);
            options.apiLocation = useApiDevServer;
        }
        // make sure api folder exists
        else if (fs_1.default.existsSync(options.apiLocation) === false) {
            utils_1.logger.info(`Skipping API because folder "${options.apiLocation}" is missing.`);
        }
    }
    // get the app and api artifact locations
    let [appLocation, appArtifactLocation, apiLocation] = [
        options.appLocation,
        options.appArtifactLocation,
        options.apiLocation,
    ];
    let apiPort = (options.apiPort || config_1.DEFAULT_CONFIG.apiPort);
    let userConfig = {
        appLocation,
        appArtifactLocation,
        apiLocation,
    };
    // mix CLI args with the project's build workflow configuration (if any)
    // use any specific workflow config that the user might provide undef ".github/workflows/"
    // Note: CLI args will take precedence over workflow config
    userConfig = utils_1.readWorkflowFile({
        userConfig,
    });
    const isApiLocationExistsOnDisk = fs_1.default.existsSync(userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation);
    // parse the API URI port
    // handle the API location config
    let serveApiCommand = "echo No API found. Skipping";
    if (useApiDevServer) {
        serveApiCommand = `echo 'using API dev server at ${useApiDevServer}'`;
        // get the API port from the dev server
        apiPort = (_a = utils_1.parseUrl(useApiDevServer)) === null || _a === void 0 ? void 0 : _a.port;
    }
    else {
        if (options.apiLocation && (userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation)) {
            // @todo check if the func binary is globally available
            const funcBinary = "func";
            // serve the api if and only if the user provides a folder via the --api-location flag
            if (isApiLocationExistsOnDisk) {
                serveApiCommand = `cd ${userConfig.apiLocation} && ${funcBinary} start --cors * --port ${options.apiPort}`;
            }
        }
    }
    // set env vars for current command
    const envVarsObj = {
        SWA_CLI_DEBUG: options.verbose,
        SWA_CLI_API_PORT: `${apiPort}`,
        SWA_CLI_APP_LOCATION: userConfig === null || userConfig === void 0 ? void 0 : userConfig.appLocation,
        SWA_CLI_APP_ARTIFACT_LOCATION: userConfig === null || userConfig === void 0 ? void 0 : userConfig.appArtifactLocation,
        SWA_CLI_API_LOCATION: userConfig === null || userConfig === void 0 ? void 0 : userConfig.apiLocation,
        SWA_CLI_HOST: options.host,
        SWA_CLI_PORT: `${options.port}`,
        SWA_WORKFLOW_FILES: (_b = userConfig === null || userConfig === void 0 ? void 0 : userConfig.files) === null || _b === void 0 ? void 0 : _b.join(","),
    };
    if ((_c = options.verbose) === null || _c === void 0 ? void 0 : _c.includes("silly")) {
        // when silly level is set,
        // propagate debugging level to other tools using the DEBUG environment variable
        process.env.DEBUG = "*";
    }
    // merge SWA env variables with process.env
    process.env = { ...process.env, ...envVarsObj };
    const { env } = process;
    const concurrentlyCommands = [
        // start the reverse proxy
        { command: `node ${path_1.default.join(__dirname, "..", "..", "proxy", "server.js")}`, name: "swa", env, prefixColor: "gray.dim" },
    ];
    if (isApiLocationExistsOnDisk) {
        concurrentlyCommands.push(
        // serve the api, if it's available
        { command: serveApiCommand, name: "api", env, prefixColor: "gray.dim" });
    }
    if (options.build) {
        // run the app/api builds
        await builder_1.default({
            config: userConfig,
        });
    }
    console.log({
        options,
    });
    utils_1.logger.silly({
        env: envVarsObj,
        commands: {
            app: concurrentlyCommands[0].command,
            api: (_d = concurrentlyCommands === null || concurrentlyCommands === void 0 ? void 0 : concurrentlyCommands[1]) === null || _d === void 0 ? void 0 : _d.command,
        },
    }, "swa");
    await concurrently_1.default(concurrentlyCommands, {
        restartTries: 0,
        prefix: "name",
    }).then(() => process.exit(), () => process.exit());
}
exports.start = start;
//# sourceMappingURL=start.js.map